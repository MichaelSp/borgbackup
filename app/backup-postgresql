#!/usr/bin/env sh
set -e

. /app/lib.sh
KEY=${1}

[ -z "${KEY}" ] && echo "KEY is required" && exit 1
[ -z "${BACKUP_CONFIG_YAML}" ] && echo "BACKUP_CONFIG_YAML is required" && exit 1

CONFIG=$(yq eval ".${KEY}" "${BACKUP_CONFIG_YAML}")
TMPDIR=$(mktemp -d)
trap "rm -rf ${TMPDIR}" EXIT

if [ "${CONFIG}" = "" ] || [ "${CONFIG}" = "null" ]; then
  echo "ðŸ¤– No config found for '${KEY}'"
  exit 1
fi

DUMP_AS_ADMIN=$(echo "${CONFIG}" | yq '.use_postgres_admin // true')
NAMESPACE=$(echo "${CONFIG}" | yq '.namespace')
APP_NAME=$(echo "${CONFIG}" | yq '.helmReleaseName')
COMPRESSION=$(echo "${CONFIG}" | yq '.compression // env(DEFAULT_COMPRESSION)')
KEEP=$(echo "${CONFIG}" | yq '.keep // env(DEFAULT_KEEP)')

if [ "$DUMP_AS_ADMIN" != "true" ] && [ "$DUMP_AS_ADMIN" != "false" ]; then
  echo "ðŸ¤– use_postgres_admin for '${KEY}' is not a boolean"
  exit 1
fi

if [ ! "$(echo "${CONFIG}" | yq '.type')" = "postgresql" ]; then
  echo "ðŸ¤– Config for '${KEY}' is not of type 'postgresql'"
  exit 1
fi

if [ -z "$APP_NAME" ] || [ -z "$NAMESPACE" ]; then
  echo "NAMESPACE and APP_NAME is required ðŸ’¥"
  exit 1
fi

FILTER="app.kubernetes.io/name=postgresql,app.kubernetes.io/instance=${APP_NAME},app.kubernetes.io/component=primary"

POD_YAML=$(kubectl get statefulset -n $NAMESPACE -l $FILTER -o json)

# extract pod name
STATEFUL_SET_NAME=$(echo "${POD_YAML}" | yq '.items[0].metadata.name')
if [ -z "$STATEFUL_SET_NAME" ] || [ "$STATEFUL_SET_NAME" = "null" ]; then
echo "ERROR: No StatefulSet found for 'app.kubernetes.io/instance=${APP_NAME}' in namespace '$NAMESPACE'"
exit 1
fi

# fail if source pod not running
if ! kubectl get pods -n "$NAMESPACE" -l "$FILTER"; then
  echo "ERROR: No pod found for 'app.kubernetes.io/instance=${APP_NAME}' in namespace '$NAMESPACE' - is pod running?"
  exit 1
fi

# extract secret name
SECRET_NAME=$(echo "${POD_YAML}" | yq '.items[0].spec.template.spec.containers[0].env[] | select(.name == "POSTGRES_PASSWORD") | .valueFrom.secretKeyRef.name')
if [ -z "$SECRET_NAME" ]; then
  echo "ERROR: No secret found for '${APP_NAME}' in namespace '$NAMESPACE' - searching for an env var named 'POSTGRES_PASSWORD'"
  echo "spec: ${POD_YAML}"
  exit 1
fi

## check if pod is running
if ! kubectl get pods -n "$NAMESPACE" -l "$FILTER"; then
  echo "ERROR: No pod found for 'app.kubernetes.io/instance=${APP_NAME}' in namespace '$NAMESPACE'"
  exit 1
fi

POD_NAME=$(kubectl get pods -n "$NAMESPACE" -l "$FILTER" -o jsonpath="{.items[0].metadata.name}")
SECRET_KEY='postgres-password'
if [ "$DUMP_AS_ADMIN" = false ]; then
  SECRET_KEY='password'
fi

PGPASSWORD=$(kubectl get secrets -n "$NAMESPACE" "$SECRET_NAME" -o jsonpath="{.data.${SECRET_KEY}}" | base64 -d)

if [ -z $PGPASSWORD ]; then
  echo "ERROR: No password found in secret '${SECRET_NAME}' in namespace '$NAMESPACE'"
  exit 1
fi

if [ "$DUMP_AS_ADMIN" = false ]; then
  # in case of error: failed: FATAL:  password authentication failed for user "<some-user>", comment out the following line
  PGUSER=$(echo "${POD_YAML}" | yq '.items[0].spec.template.spec.containers[0].env[] | select(.name == "POSTGRES_USER") | .value')
fi
#
# if use_postgres_admin is true or no user was found, use postgres user
if [ -z "$PGUSER" ]; then
  PGUSER="postgres"
fi

POSTGRES_DATABASE=$(echo "${POD_YAML}" | yq '.items[0].spec.template.spec.containers[0].env[] | select(.name == "POSTGRES_DATABASE") | .value')
if [ -z "$POSTGRES_DATABASE" ]; then
POSTGRES_DATABASE="postgres"
fi

echo "ðŸ¤– Dumping database '${POSTGRES_DATABASE}' from pod '${POD_NAME}' in namespace '${NAMESPACE}'"

SRC="${TMPDIR}/dump.sql"
DATE=$(date +%Y-%m-%d-%H-%M-%S)
kubectl exec -n $NAMESPACE $POD_NAME -- bash -c "PGPASSWORD=${PGPASSWORD} pg_dump -h $POD_NAME -U $PGUSER -d $POSTGRES_DATABASE -w" > $SRC

echo "ðŸ¤– DUMP Done"
echo "ðŸ¤– Running borg backup for '${KEY}' from '$SRC'"
borg create --stats --progress --compression "${COMPRESSION}" "${BORG_REPO}::${KEY}-${DATE}" "${SRC}"

echo "ðŸ¤– Pruning old backups..."
borg prune --list --keep-within "${KEEP}"